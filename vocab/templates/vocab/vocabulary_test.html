{% extends 'users/base.html' %}

{% block title %}Vocabulary Test{% endblock %}

{% block content %}
<div class="container mt-4">
    <div class="row">
        <div class="col-12">
            <h1 class="mb-4">Vocabulary Test</h1>
            <div class="card">
                <div class="card-body">
                    <div id="test-root">
                        <div class="mb-3">
                            <span id="word" class="fs-1"></span>
                        </div>
                        <div class="mb-3">
                            <button id="btn-know" class="btn btn-success me-2">Know it</button>
                            <button id="btn-dont" class="btn btn-outline-danger">Don't know</button>
                        </div>
                        <div class="mb-3">
                            <span class="me-3">Vocab size: <span id="rstar">-</span></span>
                            <span class="me-3">Misses: <span id="misses">0</span></span>
                        </div>
                        <div class="small text-muted" id="status"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script>
const CSV_MAX_RANK = 5000
const START_RANK = 1200
const K_SCALE = 0.05
const P_INTERCEPT = 1.0
const Q_SHAPE = 2.0
const MISS_FACTOR = 0.9

let ranks = []
let rankToWord = new Map()
let asked = new Set()
let responses = new Map()
let rStar = null
let missed = []
let currentRank = null

function alphaVector(ranksArr, Rstar, missedRanks) {
  if (!Rstar) return ranksArr.map(() => 0)
  const A = K_SCALE * Math.pow(Rstar, P_INTERCEPT)
  const mr = [...missedRanks].sort((a,b)=>a-b)
  return ranksArr.map(r => {
    const frac = Math.max(0, Math.min(1, 1 - (r - 1) / Rstar))
    let base = A * Math.pow(frac, Q_SHAPE)
    if (mr.length) {
      let cnt = 0
      for (let i=0;i<mr.length;i++) if (mr[i] <= r) cnt++
      base *= Math.pow(MISS_FACTOR, cnt)
    }
    return base
  })
}

function expectedVocabSize() {
  const vals = alphaVector(ranks, rStar, missed)
  return vals.reduce((a,b)=>a+b, 0)
}

function isAvailable(r) {
  return r && r >= 1 && r <= CSV_MAX_RANK && !asked.has(r)
}

function pickFirstRank() {
  if (isAvailable(START_RANK)) return START_RANK
  for (let d=1; d<1000; d++) {
    for (const r of [START_RANK-d, START_RANK+d]) {
      if (isAvailable(r)) return r
    }
  }
  const remain = ranks.filter(r => isAvailable(r))
  return remain.length ? remain[Math.floor(Math.random()*remain.length)] : null
}

function pickNextRank(prev, knew) {
  if (!prev) return pickFirstRank()
  let lo = knew ? prev+1 : prev-300
  let hi = knew ? prev+200 : prev+300
  lo = Math.max(1, lo)
  hi = Math.min(CSV_MAX_RANK, hi)
  let window = []
  for (let r=lo; r<=hi; r++) if (isAvailable(r)) window.push(r)
  if (!window.length) {
    lo = knew ? Math.max(1, prev+1) : Math.max(1, prev-600)
    hi = knew ? Math.min(CSV_MAX_RANK, prev+400) : Math.min(CSV_MAX_RANK, prev+600)
    for (let r=lo; r<=hi; r++) if (isAvailable(r)) window.push(r)
  }
  if (!window.length) window = ranks.filter(r => isAvailable(r))
  return window.length ? window[Math.floor(Math.random()*window.length)] : null
}

async function loadRanks() {
  const res = await fetch('/vocab/test/ranks/', { credentials: 'same-origin' })
  if (res.status === 401) {
    document.getElementById('status').textContent = 'Please login to continue'
    throw new Error('Unauthorized')
  }
  const ct = res.headers.get('content-type') || ''
  if (!ct.includes('application/json')) {
    document.getElementById('status').textContent = 'Please login to continue'
    throw new Error('Non-JSON response')
  }
  const data = await res.json()
  if (!data.success) throw new Error(data.error || 'Failed to load ranks')
  ranks = data.words.map(w => w.rank)
  rankToWord = new Map(data.words.map(w => [w.rank, w.word]))
}

function showWord(rank) {
  currentRank = rank
  document.getElementById('word').textContent = rank ? (rankToWord.get(rank) || `[Rank ${rank}]`) : 'â€”'
  document.getElementById('status').textContent = `Item ${asked.size + 1}`
  document.getElementById('rstar').textContent = rStar || '-'
  document.getElementById('misses').textContent = missed.length
  document.getElementById('evs').textContent = expectedVocabSize().toFixed(1)
}

async function sendBatch(alphaPairs, betaPairs) {
  const chunkSize = 500
  const chunks = []
  for (let i=0;i<alphaPairs.length;i+=chunkSize) chunks.push({a: alphaPairs.slice(i,i+chunkSize), b: []})
  for (let i=0;i<betaPairs.length;i+=chunkSize) chunks.push({a: [], b: betaPairs.slice(i,i+chunkSize)})
  for (const ch of chunks) {
    const res = await fetch('/vocab/test/batch-update/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify({ alpha: ch.a, beta: ch.b })
    })
    await res.json().catch(()=>{})
  }
  return { success: true }
}

async function answer(knew) {
  if (!currentRank) return
  const r = currentRank
  asked.add(r)
  responses.set(r, knew ? 1 : 0)
  if (knew) {
    if (!rStar || r > rStar) rStar = r
  } else {
    missed.push(r)
  }
  if (knew) {
    const upto = ranks.filter(x => x <= r)
    const alphas = alphaVector(upto, r, missed)
    const alphaPairs = upto.map((rk, i) => [rankToWord.get(rk) || '', alphas[i]])
    const filtered = alphaPairs.filter(p => p[0])
    if (filtered.length) sendBatch(filtered, []).catch(()=>{})
  } else {
    const w = rankToWord.get(r) || ''
    if (w) sendBatch([], [[w, 20]]).catch(()=>{})
  }
  const nextR = pickNextRank(r, !!knew)
  showWord(nextR)
}

document.addEventListener('DOMContentLoaded', async () => {
  try {
    await loadRanks()
    const first = pickFirstRank()
    showWord(first)
    document.getElementById('btn-know').addEventListener('click', () => answer(true))
    document.getElementById('btn-dont').addEventListener('click', () => answer(false))
  } catch (e) {
    document.getElementById('status').textContent = String(e)
  }
})
</script>
{% endblock %}
